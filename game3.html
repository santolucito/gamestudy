<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Trebuchet MS', monospace;
            background-color: #ffffff;
            color: #000000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        #game-container {
            text-align: center;
            position: relative;
        }

        #instructions {
            margin-bottom: 20px;
            font-size: 14px;
            padding: 15px;
            background-color: #ffffff;
            color: #1a1a1a;
            border-radius: 8px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.5;
            text-align: center;
            opacity: 1;
            transition: opacity 0.5s ease-in-out;
        }

        #grid {
            display: inline-grid;
            grid-template-columns: repeat(7, 111px);
            grid-template-rows: repeat(7, 111px);
            gap: 2px;
            background-color: #e0e0e0;
            padding: 2px;
            border: 3px solid #e0e0e0;
            opacity: 1;
            transition: opacity 0.5s ease-in-out;
        }

        #grid.fade-out {
            opacity: 0;
        }

        .cell {
            width: 111px;
            height: 111px;
            border: 1px solid #ddd;
            box-sizing: border-box;
            transition: all 0.2s ease;
        }

        #ripple-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ripple {
            position: absolute;
            border-radius: 50%;
            border: 7px solid #32CD32;
            opacity: 2;
        }

        @keyframes ripple {
            0% {
                width: 0;
                height: 0;
                opacity: 0.8;
            }
            100% {
                width: 400px;
                height: 400px;
                opacity: 0;
            }
        }

        #button-container {
            display: none;
        }

        #restart-button, #download-button {
            position: fixed;
            top: 20px;
            padding: 15px 30px;
            font-size: 18px;
            font-family: 'Trebuchet MS', monospace;
            background-color: #ffffff;
            color: #1a1a1a;
            border: 3px solid #1a1a1a;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        #restart-button {
            left: 20px;
            display: none;
        }

        #download-button {
            right: 20px;
            display: block;
        }

        #restart-button:hover, #download-button:hover {
            background-color: #1a1a1a;
            color: #ffffff;
        }
    </style>
</head>
<body>
    <div id="instructions">
        There are no instructions for this game, intentionally.<br>Use the arrow keys, "B" key, and space bar to discover the controls, rules, and objective.
    </div>
    <div id="game-container">
        <div id="ripple-container"></div>
        <div id="grid"></div>
    </div>
    <button id="restart-button">Start Over</button>
    <button id="download-button">Download Data</button>

    <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
    <script src="audio-recorder.js"></script>
    <script>
        // Game state
        let levels = [];
        let currentLevelIndex = 0;
        let isBKeyPressed = false; // Track if B key is being held
        let gameState = {
            grid: [],
            chunks: [],
            selectedChunkIndex: 0,
            vehiclePos: { row: 0, col: 0 },
            goalPos: { row: 0, col: 0 },
            colors: {}
        };

        // Session logging
        let sessionData = {
            sessionStart: new Date().toISOString(),
            events: []
        };

        // ===========================
        // GRID VALUE LEGEND
        // ===========================
        // 0 = Empty cell (background)
        // 1 = Movable track (can be part of chunks that move)
        // 2 = Fixed track (cannot move, stays in place)
        // 3 = Vehicle (starting position)
        // 4 = Goal (hidden, where vehicle needs to reach)
        //
        // chunks: array of coordinate groups [[row,col],[row,col],...]
        //         - defines which movable tracks (1's) move together
        //         - coordinates are [row, col] where row 0 is top, col 0 is left
        // ===========================

        // Level definitions
        function level1() {
            return {
                id: 1,
                name: "Level 1",
                grid: [
                    [0,0,0,0,0,0,0],
                    [0,0,1,1,0,0,0],
                    [0,0,0,0,0,0,0],
                    [3,0,0,0,2,2,4],
                    [0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0],
                    [0,0,0,1,1,0,0],
                ],
                chunks: [
                    [[1,2],[1,3]],  // Two-cell chunk that moves together
                    [[6,3]],        // Single moveable cell
                    [[6,4]],        // Single moveable cell
                ],
                vehicleStart: [3,0],
                goal: [3,6],
                colors: {
                    background: "#FFFFFF",
                    track: "#ADD8E6",
                    fixedTrack: "#ADD8E6",
                    vehicle: "#DDCC77",
                    goal: "#00CC66",
                    selectedChunk: "#D3D3D3"
                }
            };
        }

        function level2() {
            return {
                id: 2,
                name: "Level 2",
                grid: [
                    [0,0,0,3,0,0,1],
                    [0,0,0,0,0,0,1],
                    [0,0,0,2,0,0,0],
                    [0,0,0,0,1,0,0],
                    [0,0,1,0,0,0,0],
                    [0,0,0,2,0,0,0],
                    [0,0,0,4,0,0,0],
                ],
                chunks: [
                    [[0,6],[1,6]],  // Two-cell chunk at top right
                    [[4,2]],        // Single moveable pixel
                    [[3,4]],        // Single moveable pixel
                ],
                vehicleStart: [0,3],
                goal: [6,3],
                colors: {
                    background: "#FFFFFF",
                    track: "#44AA99",
                    fixedTrack: "#44AA99",
                    vehicle: "#CC6677",
                    goal: "#00FF99",
                    selectedChunk: "#D3D3D3"
                }
            };
        }

        function level3() {
            return {
                id: 3,
                name: "Level 3",
                grid: [
                    [3,0,0,0,0,0,0],
                    [0,0,0,0,0,1,0],
                    [0,2,2,1,0,0,0],
                    [0,0,2,1,1,1,0],
                    [0,0,0,0,0,0,0],
                    [0,0,0,0,0,2,2],
                    [1,1,0,0,0,0,4],
                ],
                chunks: [
                    [[6,0],[6,1]],           // Two-cell chunk bottom left
                    [[2,3],[3,3],[3,4],[3,5]], // Four-cell chunk
                    [[1,5]],                 // Single moveable pixel
                ],
                vehicleStart: [0,0],
                goal: [6,6],
                colors: {
                    background: "#FFFFFF",
                    track: "#BBCC33",
                    fixedTrack: "#BBCC33",
                    vehicle: "#332288",
                    goal: "#33FF66",
                    selectedChunk: "#D3D3D3"
                }
            };
        }

        function level4() {
            return {
                id: 4,
                name: "Level 4",
                grid: [
                    [0,0,0,3,0,0,0],
                    [0,1,0,0,0,0,0],
                    [0,0,0,0,1,1,0],
                    [0,0,2,2,0,0,3],
                    [0,0,2,1,1,0,1],
                    [2,0,0,0,0,0,1],
                    [4,0,0,0,0,0,0],
                ],
                chunks: [
                    [[4,3],[4,4]],  // Two-pixel moveable chunk
                    [[4,6],[5,6]],  // Two-pixel moveable chunk
                    [[1,1]],        // Single moveable pixel
                    [[2,4],[2,5]],  // Two-pixel moveable chunk
                ],
                vehicleStart: [0,3],  // First vehicle position
                goal: [6,0],      // Goal where both vehicles meet
                colors: {
                    background: "#FFFFFF",
                    track: "#882255",
                    fixedTrack: "#882255",
                    vehicle: "#88CCEE",
                    goal: "#00CCFF",
                    selectedChunk: "#D3D3D3"
                }
            };
        }

        // Initialize grid display
        function initGrid() {
            const gridElement = document.getElementById('grid');
            gridElement.innerHTML = '';
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 7; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${row}-${col}`;
                    gridElement.appendChild(cell);
                }
            }
        }

        // Load level
        function loadLevel(levelIndex) {
            if (levelIndex >= levels.length) {
                return;
            }

            const level = levels[levelIndex];
            gameState.grid = level.grid.map(row => [...row]);
            gameState.chunks = level.chunks.map(chunk => chunk.map(cell => [...cell]));
            gameState.selectedChunkIndex = 0;
            gameState.vehiclePos = { row: level.vehicleStart[0], col: level.vehicleStart[1] };
            gameState.goalPos = { row: level.goal[0], col: level.goal[1] };
            gameState.colors = { ...level.colors };

            renderGrid();

            // Fade in
            const gridElement = document.getElementById('grid');
            gridElement.classList.remove('fade-out');
        }

        // Render the grid
        function renderGrid() {
            const selectedChunk = gameState.chunks[gameState.selectedChunkIndex];

            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 7; col++) {
                    const cell = document.getElementById(`cell-${row}-${col}`);
                    const gridValue = gameState.grid[row][col];

                    let color = gameState.colors.background;
                    let isSelected = false;

                    // Check if this cell is part of the selected chunk
                    if (selectedChunk) {
                        for (const [r, c] of selectedChunk) {
                            if (r === row && c === col) {
                                isSelected = true;
                                break;
                            }
                        }
                    }

                    // Determine color based on grid value
                    if (gridValue === 1) {
                        // If B key is pressed, show all tracks in track color (no selection)
                        // Otherwise, show selected chunks in selectedChunk color
                        if (isBKeyPressed) {
                            color = gameState.colors.track;
                        } else {
                            color = isSelected ? gameState.colors.selectedChunk : gameState.colors.track;
                        }
                    } else if (gridValue === 2) {
                        color = gameState.colors.fixedTrack;
                    } else if (gridValue === 3) {
                        color = gameState.colors.vehicle;
                    } else if (gridValue === 4) {
                        color = gameState.colors.background; // Goal is hidden
                    }

                    cell.style.backgroundColor = color;
                }
            }
        }

        // Move selected chunk
        function moveChunk(dRow, dCol) {
            const chunk = gameState.chunks[gameState.selectedChunkIndex];
            if (!chunk) return;

            // Check if move is valid
            const newPositions = chunk.map(([r, c]) => [r + dRow, c + dCol]);

            // Check bounds
            for (const [r, c] of newPositions) {
                if (r < 0 || r >= 7 || c < 0 || c >= 7) {
                    return; // Out of bounds
                }
            }

            // Check collisions with fixed track, vehicle, and other chunks
            // Note: Goal (4) is allowed - chunks can move over it
            for (const [r, c] of newPositions) {
                const gridValue = gameState.grid[r][c];

                // Skip if empty or goal (both are passable)
                if (gridValue === 0 || gridValue === 4) {
                    continue;
                }

                // Check if this position is part of the current chunk (which is okay)
                let isPartOfCurrentChunk = false;
                for (const [cr, cc] of chunk) {
                    if (cr === r && cc === c) {
                        isPartOfCurrentChunk = true;
                        break;
                    }
                }

                // If occupied by something that's NOT part of current chunk, collision!
                if (!isPartOfCurrentChunk) {
                    return; // Collision detected
                }
            }

            // Clear old positions
            for (const [r, c] of chunk) {
                if (gameState.grid[r][c] === 1) {
                    gameState.grid[r][c] = 0;
                }
            }

            // Update chunk positions
            for (let i = 0; i < chunk.length; i++) {
                chunk[i] = newPositions[i];
            }

            // Place chunk in new positions
            for (const [r, c] of chunk) {
                gameState.grid[r][c] = 1;
            }

            renderGrid();
        }

        // Cycle to next chunk
        function cycleChunk() {
            gameState.selectedChunkIndex = (gameState.selectedChunkIndex + 1) % gameState.chunks.length;
            renderGrid();
        }

        // Pathfinding: BFS to check if vehicle(s) can reach goal
        function canReachGoal() {
            const goal = gameState.goalPos;

            // Find all vehicle positions in the grid
            const vehiclePositions = [];
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 7; col++) {
                    if (gameState.grid[row][col] === 3) {
                        vehiclePositions.push([row, col]);
                    }
                }
            }

            // Check if EACH vehicle can reach the goal
            for (const [startRow, startCol] of vehiclePositions) {
                const queue = [[startRow, startCol]];
                const visited = new Set();
                visited.add(`${startRow},${startCol}`);

                let canReach = false;

                while (queue.length > 0) {
                    const [row, col] = queue.shift();

                    // Check if we reached the goal
                    if (row === goal.row && col === goal.col) {
                        canReach = true;
                        break;
                    }

                    // Check all 4 adjacent cells
                    const neighbors = [
                        [row - 1, col],
                        [row + 1, col],
                        [row, col - 1],
                        [row, col + 1]
                    ];

                    for (const [nRow, nCol] of neighbors) {
                        if (nRow < 0 || nRow >= 7 || nCol < 0 || nCol >= 7) continue;

                        const key = `${nRow},${nCol}`;
                        if (visited.has(key)) continue;

                        const gridValue = gameState.grid[nRow][nCol];
                        // Can move on track (1), fixed track (2), vehicle (3), or goal (4)
                        if (gridValue === 1 || gridValue === 2 || gridValue === 3 || gridValue === 4) {
                            visited.add(key);
                            queue.push([nRow, nCol]);
                        }
                    }
                }

                // If ANY vehicle cannot reach the goal, return false
                if (!canReach) {
                    return false;
                }
            }

            // All vehicles can reach the goal
            return true;
        }

        // Move vehicle
        function moveVehicle() {
            if (!canReachGoal()) {
                return; // Path not complete
            }

            // Clear vehicle(s) from old position(s)
            // For Level 4 with two vehicles, clear both; otherwise just clear the one
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 7; col++) {
                    if (gameState.grid[row][col] === 3) {
                        gameState.grid[row][col] = 1; // Convert vehicle to track
                    }
                }
            }

            // Move vehicle to goal (both vehicles converge to same position in Level 4)
            gameState.vehiclePos = { ...gameState.goalPos };
            gameState.grid[gameState.vehiclePos.row][gameState.vehiclePos.col] = 3;

            // Clear selection so pathway shows uniformly on completion
            gameState.selectedChunkIndex = -1;

            renderGrid();

            // Win! Move to next level
            createRipple();

            const gridElement = document.getElementById('grid');
            gridElement.classList.add('fade-out');

            setTimeout(() => {
                currentLevelIndex++;
                if (currentLevelIndex < levels.length) {
                    loadLevel(currentLevelIndex);
                } else {
                    // Game complete - show restart button
                    gridElement.classList.remove('fade-out');
                    document.getElementById('restart-button').style.display = 'block';
                }
            }, 800);
        }

        // Create ripple effect
        function createRipple() {
            const container = document.getElementById('ripple-container');

            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const ripple = document.createElement('div');
                    ripple.className = 'ripple';
                    ripple.style.animation = 'ripple 1s ease-out';
                    container.appendChild(ripple);

                    setTimeout(() => {
                        ripple.remove();
                    }, 1000);
                }, i * 200);
            }
        }

        // Generate game state matrix
        function generateGameStateMatrix() {
            // Initialize 7x7 matrix with empty cells
            const matrix = Array(7).fill(null).map(() => Array(7).fill('E'));

            // Populate matrix based on grid values
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 7; col++) {
                    const gridValue = gameState.grid[row][col];

                    if (gridValue === 0) {
                        matrix[row][col] = 'E';  // Empty
                    } else if (gridValue === 1) {
                        matrix[row][col] = 'M';  // Movable track
                    } else if (gridValue === 2) {
                        matrix[row][col] = 'F';  // Fixed track
                    } else if (gridValue === 3) {
                        matrix[row][col] = 'V';  // Vehicle
                    } else if (gridValue === 4) {
                        matrix[row][col] = 'G';  // Goal
                    }
                }
            }

            return matrix;
        }

        // Log event
        function logEvent(key, action) {
            sessionData.events.push({
                timestamp: new Date().toISOString(),
                level: currentLevelIndex + 1,
                key: key,
                action: action,
                gameStateBefore: generateGameStateMatrix(),
                selectedChunk: gameState.selectedChunkIndex
            });
        }

        // Keyboard handling
        document.addEventListener('keydown', (e) => {
            if (currentLevelIndex >= levels.length) return;

            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    logEvent('ArrowUp', 'move_chunk_up');
                    moveChunk(-1, 0);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    logEvent('ArrowDown', 'move_chunk_down');
                    moveChunk(1, 0);
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    logEvent('ArrowLeft', 'move_chunk_left');
                    moveChunk(0, -1);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    logEvent('ArrowRight', 'move_chunk_right');
                    moveChunk(0, 1);
                    break;
                case ' ':
                    e.preventDefault();
                    logEvent('Space', 'cycle_chunk');
                    cycleChunk();
                    break;
                case 'b':
                case 'B':
                    e.preventDefault();
                    if (!isBKeyPressed) {
                        isBKeyPressed = true;
                        renderGrid(); // Re-render to show flash effect
                        logEvent('B', 'attempt_move_vehicle');
                        moveVehicle();
                    }
                    break;
                case 'r':
                case 'R':
                    e.preventDefault();
                    logEvent('R', 'restart_level');
                    loadLevel(currentLevelIndex);
                    break;
            }
        });

        // Handle B key release to stop flash effect
        document.addEventListener('keyup', (e) => {
            if (e.key === 'b' || e.key === 'B') {
                isBKeyPressed = false;
                renderGrid(); // Re-render to restore selection
            }
        });

        // Restart button
        document.getElementById('restart-button').addEventListener('click', () => {
            currentLevelIndex = 0;
            document.getElementById('restart-button').style.display = 'none';

            // Reset session data
            sessionData = {
                sessionStart: new Date().toISOString(),
                events: []
            };

            loadLevel(currentLevelIndex);
        });

        // Download button
        document.getElementById('download-button').addEventListener('click', () => {
            sessionData.sessionEnd = new Date().toISOString();

            // Convert to JSON with standard formatting first
            let dataStr = JSON.stringify(sessionData, null, 2);

            // Post-process to compress gameStateBefore arrays into compact rows
            // Find each gameStateBefore array and compress its rows
            dataStr = dataStr.replace(
                /"gameStateBefore":\s*\[\s*\[\s*("[A-Z]",?\s*)+\]\s*(,\s*\[\s*("[A-Z]",?\s*)+\]\s*)*\]/g,
                (match) => {
                    // Extract all letters from this matrix
                    const letters = match.match(/"[A-Z]"/g);
                    if (!letters) return match;

                    // Group into rows of 7 (for 7x7 grid)
                    const rows = [];
                    for (let i = 0; i < letters.length; i += 7) {
                        rows.push('[' + letters.slice(i, i + 7).join(',') + ']');
                    }

                    // Format with proper indentation
                    return '"gameStateBefore": [\n        ' + rows.join(',\n        ') + '\n      ]';
                }
            );

            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `track-puzzle-session-${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Initialize game
        levels = [level1(), level2(), level3(), level4()];
        initGrid();
        loadLevel(0);

        // Initialize audio recorder
        AudioRecorder.init({
            gamePrefix: 'puzzle-game3',
            getGameState: function() {
                return {
                    level: currentLevelIndex + 1,
                    vehiclePos: { ...gameState.vehiclePos },
                    goalPos: { ...gameState.goalPos },
                    selectedChunkIndex: gameState.selectedChunkIndex,
                    chunks: gameState.chunks.map(chunk => chunk.map(cell => [...cell])),
                    gameStateMatrix: generateGameStateMatrix(),
                    isBKeyPressed: isBKeyPressed
                };
            },
            screenToGrid: function(screenX, screenY) {
                const grid = document.getElementById('grid');
                const rect = grid.getBoundingClientRect();

                // Check if point is within grid bounds
                if (screenX < rect.left || screenX > rect.right ||
                    screenY < rect.top || screenY > rect.bottom) {
                    return null; // Off grid
                }

                // Convert to grid coordinates (0-6 for 7x7 grid)
                const cellWidth = rect.width / 7;
                const cellHeight = rect.height / 7;
                const col = Math.floor((screenX - rect.left) / cellWidth);
                const row = Math.floor((screenY - rect.top) / cellHeight);

                return { x: Math.min(col, 6), y: Math.min(row, 6) };
            }
        });
    </script>
</body>
</html>
