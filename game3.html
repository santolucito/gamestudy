<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Track Puzzle Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Trebuchet MS', monospace;
            background-color: #f5f5f5;
            color: #000000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        #game-container {
            text-align: center;
            position: relative;
        }

        #instructions {
            margin-bottom: 20px;
            font-size: 16px;
            padding: 15px;
            background-color: #ffffff;
            border-radius: 8px;
            max-width: 600px;
            line-height: 1.6;
        }

        #grid {
            display: inline-grid;
            grid-template-columns: repeat(7, 60px);
            grid-template-rows: repeat(7, 60px);
            gap: 2px;
            padding: 2px;
            border: 3px solid #333;
            opacity: 1;
            transition: opacity 0.5s ease-in-out;
        }

        #grid.fade-out {
            opacity: 0;
        }

        .cell {
            width: 60px;
            height: 60px;
            border: 1px solid #ddd;
            box-sizing: border-box;
            transition: all 0.2s ease;
        }

        #ripple-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ripple {
            position: absolute;
            border-radius: 50%;
            border: 7px solid #32CD32;
            opacity: 2;
        }

        @keyframes ripple {
            0% {
                width: 0;
                height: 0;
                opacity: 0.8;
            }
            100% {
                width: 400px;
                height: 400px;
                opacity: 0;
            }
        }

        #restart-button, #download-button {
            display: none;
            margin: 20px auto;
            padding: 15px 30px;
            font-size: 18px;
            font-family: 'Trebuchet MS', monospace;
            background-color: #ffffff;
            color: #1a1a1a;
            border: 3px solid #1a1a1a;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #restart-button:hover, #download-button:hover {
            background-color: #1a1a1a;
            color: #ffffff;
        }

        #download-button {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        #level-indicator {
            margin-bottom: 15px;
            font-size: 20px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="level-indicator"></div>
    <div id="instructions">
        There are no instructions for this game, intentionally. Use the arrow keys, "B" key, and space bar to discover the controls, rules, and objective.
    </div>
    <div id="game-container">
        <div id="ripple-container"></div>
        <div id="grid"></div>
    </div>
    <button id="restart-button">Start Over</button>
    <button id="download-button">Download Data</button>

    <script>
        // Game state
        let levels = [];
        let currentLevelIndex = 0;
        let gameState = {
            grid: [],
            chunks: [],
            selectedChunkIndex: 0,
            carPos: { row: 0, col: 0 },
            goalPos: { row: 0, col: 0 },
            colors: {}
        };

        // Session logging
        let sessionData = {
            sessionStart: new Date().toISOString(),
            events: []
        };

        // ===========================
        // GRID VALUE LEGEND
        // ===========================
        // 0 = Empty cell (background)
        // 1 = Movable track (can be part of chunks that move)
        // 2 = Fixed track (cannot move, stays in place)
        // 3 = Car (starting position)
        // 4 = Goal (hidden, where car needs to reach)
        //
        // chunks: array of coordinate groups [[row,col],[row,col],...]
        //         - defines which movable tracks (1's) move together
        //         - coordinates are [row, col] where row 0 is top, col 0 is left
        // ===========================

        // Level definitions
        function level1() {
            return {
                id: 1,
                name: "Level 1",
                grid: [
                    [0,0,0,0,0,0,0],
                    [0,2,1,1,0,0,0],
                    [0,0,0,1,0,0,0],
                    [3,1,1,1,0,0,4],
                    [0,0,0,1,0,0,0],
                    [0,0,0,1,2,0,0],
                    [0,0,0,0,0,0,0],
                ],
                chunks: [
                    [[1,2],[1,3],[2,3]],
                    [[3,1],[3,2],[3,3],[4,3]],
                    [[5,3],[5,4]],
                ],
                carStart: [3,0],
                goal: [3,6],
                colors: {
                    background: "#FFFFFF",
                    track: "#5555FF",
                    fixedTrack: "#333399",
                    car: "#FF3333",
                    goal: "#00CC66",
                    selectedChunk: "#FF88FF"
                }
            };
        }

        function level2() {
            return {
                id: 2,
                name: "Level 2",
                grid: [
                    [0,0,0,0,0,0,0],
                    [0,2,1,0,0,0,0],
                    [0,1,1,1,0,0,0],
                    [3,1,0,1,0,0,4],
                    [0,1,1,1,0,0,0],
                    [0,0,0,1,2,0,0],
                    [0,0,0,0,0,0,0],
                ],
                chunks: [
                    [[1,2],[2,1],[2,2]],
                    [[2,3],[3,1],[3,3],[4,1]],
                    [[4,2],[4,3],[5,3]],
                ],
                carStart: [3,0],
                goal: [3,6],
                colors: {
                    background: "#FFFFFF",
                    track: "#FFAA00",
                    fixedTrack: "#AA5500",
                    car: "#FF4444",
                    goal: "#00FF99",
                    selectedChunk: "#FF66FF"
                }
            };
        }

        function level3() {
            return {
                id: 3,
                name: "Level 3",
                grid: [
                    [0,0,0,0,0,0,0],
                    [0,2,0,1,0,0,0],
                    [0,1,1,1,1,0,0],
                    [3,0,1,0,1,0,4],
                    [0,1,1,1,1,0,0],
                    [0,0,0,1,0,2,0],
                    [0,0,0,0,0,0,0],
                ],
                chunks: [
                    [[1,3],[2,2],[2,3]],
                    [[2,4],[3,2],[3,4],[4,2]],
                    [[4,3],[4,4],[5,3]],
                ],
                carStart: [3,0],
                goal: [3,6],
                colors: {
                    background: "#FFFFFF",
                    track: "#00AAFF",
                    fixedTrack: "#0055AA",
                    car: "#FF3333",
                    goal: "#33FF66",
                    selectedChunk: "#FFCC00"
                }
            };
        }

        function level4() {
            return {
                id: 4,
                name: "Level 4",
                grid: [
                    [0,0,0,0,0,0,0],
                    [0,2,1,0,1,0,0],
                    [0,1,1,1,1,1,0],
                    [3,0,1,0,1,0,4],
                    [0,1,1,1,1,1,0],
                    [0,0,1,0,1,2,0],
                    [0,0,0,0,0,0,0],
                ],
                chunks: [
                    [[1,2],[1,4],[2,1],[2,2]],
                    [[2,3],[2,4],[3,2],[3,4]],
                    [[4,1],[4,2],[4,3],[4,4],[5,2],[5,4]],
                ],
                carStart: [3,0],
                goal: [3,6],
                colors: {
                    background: "#FFFFFF",
                    track: "#AAFF00",
                    fixedTrack: "#55AA00",
                    car: "#FF5555",
                    goal: "#00CCFF",
                    selectedChunk: "#FF00AA"
                }
            };
        }

        // Initialize grid display
        function initGrid() {
            const gridElement = document.getElementById('grid');
            gridElement.innerHTML = '';
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 7; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${row}-${col}`;
                    gridElement.appendChild(cell);
                }
            }
        }

        // Load level
        function loadLevel(levelIndex) {
            if (levelIndex >= levels.length) {
                return;
            }

            const level = levels[levelIndex];
            gameState.grid = level.grid.map(row => [...row]);
            gameState.chunks = level.chunks.map(chunk => chunk.map(cell => [...cell]));
            gameState.selectedChunkIndex = 0;
            gameState.carPos = { row: level.carStart[0], col: level.carStart[1] };
            gameState.goalPos = { row: level.goal[0], col: level.goal[1] };
            gameState.colors = { ...level.colors };

            // Update level indicator
            document.getElementById('level-indicator').textContent = `Level ${levelIndex + 1}`;

            renderGrid();

            // Fade in
            const gridElement = document.getElementById('grid');
            gridElement.classList.remove('fade-out');
        }

        // Render the grid
        function renderGrid() {
            const selectedChunk = gameState.chunks[gameState.selectedChunkIndex];

            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 7; col++) {
                    const cell = document.getElementById(`cell-${row}-${col}`);
                    const gridValue = gameState.grid[row][col];

                    let color = gameState.colors.background;
                    let isSelected = false;

                    // Check if this cell is part of the selected chunk
                    if (selectedChunk) {
                        for (const [r, c] of selectedChunk) {
                            if (r === row && c === col) {
                                isSelected = true;
                                break;
                            }
                        }
                    }

                    // Determine color based on grid value
                    if (gridValue === 1) {
                        // If this track piece is part of the selected chunk, use selectedChunk color
                        color = isSelected ? gameState.colors.selectedChunk : gameState.colors.track;
                    } else if (gridValue === 2) {
                        color = gameState.colors.fixedTrack;
                    } else if (gridValue === 3) {
                        color = gameState.colors.car;
                    } else if (gridValue === 4) {
                        color = gameState.colors.background; // Goal is hidden
                    }

                    cell.style.backgroundColor = color;
                }
            }
        }

        // Move selected chunk
        function moveChunk(dRow, dCol) {
            const chunk = gameState.chunks[gameState.selectedChunkIndex];
            if (!chunk) return;

            // Check if move is valid
            const newPositions = chunk.map(([r, c]) => [r + dRow, c + dCol]);

            // Check bounds
            for (const [r, c] of newPositions) {
                if (r < 0 || r >= 7 || c < 0 || c >= 7) {
                    return; // Out of bounds
                }
            }

            // Check collisions with fixed track, car, and other chunks
            for (const [r, c] of newPositions) {
                const gridValue = gameState.grid[r][c];
                if (gridValue === 2 || gridValue === 3) {
                    return; // Collision with fixed track or car
                }
            }

            // Clear old positions
            for (const [r, c] of chunk) {
                if (gameState.grid[r][c] === 1) {
                    gameState.grid[r][c] = 0;
                }
            }

            // Update chunk positions
            for (let i = 0; i < chunk.length; i++) {
                chunk[i] = newPositions[i];
            }

            // Place chunk in new positions
            for (const [r, c] of chunk) {
                gameState.grid[r][c] = 1;
            }

            renderGrid();
        }

        // Cycle to next chunk
        function cycleChunk() {
            gameState.selectedChunkIndex = (gameState.selectedChunkIndex + 1) % gameState.chunks.length;
            renderGrid();
        }

        // Pathfinding: BFS to check if car can reach goal
        function canReachGoal() {
            const start = gameState.carPos;
            const goal = gameState.goalPos;

            const queue = [[start.row, start.col]];
            const visited = new Set();
            visited.add(`${start.row},${start.col}`);

            while (queue.length > 0) {
                const [row, col] = queue.shift();

                // Check if we reached the goal
                if (row === goal.row && col === goal.col) {
                    return true;
                }

                // Check all 4 adjacent cells
                const neighbors = [
                    [row - 1, col],
                    [row + 1, col],
                    [row, col - 1],
                    [row, col + 1]
                ];

                for (const [nRow, nCol] of neighbors) {
                    if (nRow < 0 || nRow >= 7 || nCol < 0 || nCol >= 7) continue;

                    const key = `${nRow},${nCol}`;
                    if (visited.has(key)) continue;

                    const gridValue = gameState.grid[nRow][nCol];
                    // Can move on track (1), fixed track (2), or goal (4)
                    if (gridValue === 1 || gridValue === 2 || gridValue === 4) {
                        visited.add(key);
                        queue.push([nRow, nCol]);
                    }
                }
            }

            return false;
        }

        // Move car
        function moveCar() {
            if (!canReachGoal()) {
                return; // Path not complete
            }

            // Clear car from old position
            gameState.grid[gameState.carPos.row][gameState.carPos.col] = 1;

            // Move car to goal
            gameState.carPos = { ...gameState.goalPos };
            gameState.grid[gameState.carPos.row][gameState.carPos.col] = 3;

            renderGrid();

            // Win! Move to next level
            createRipple();

            const gridElement = document.getElementById('grid');
            gridElement.classList.add('fade-out');

            setTimeout(() => {
                currentLevelIndex++;
                if (currentLevelIndex < levels.length) {
                    loadLevel(currentLevelIndex);
                } else {
                    // Game complete
                    gridElement.classList.remove('fade-out');
                    document.getElementById('level-indicator').textContent = 'All Levels Complete!';
                    document.getElementById('restart-button').style.display = 'block';
                    document.getElementById('download-button').style.display = 'block';
                }
            }, 800);
        }

        // Create ripple effect
        function createRipple() {
            const container = document.getElementById('ripple-container');

            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const ripple = document.createElement('div');
                    ripple.className = 'ripple';
                    ripple.style.animation = 'ripple 1s ease-out';
                    container.appendChild(ripple);

                    setTimeout(() => {
                        ripple.remove();
                    }, 1000);
                }, i * 200);
            }
        }

        // Log event
        function logEvent(key, action) {
            sessionData.events.push({
                timestamp: new Date().toISOString(),
                level: currentLevelIndex + 1,
                key: key,
                action: action
            });
        }

        // Keyboard handling
        document.addEventListener('keydown', (e) => {
            if (currentLevelIndex >= levels.length) return;

            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    logEvent('ArrowUp', 'move_chunk_up');
                    moveChunk(-1, 0);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    logEvent('ArrowDown', 'move_chunk_down');
                    moveChunk(1, 0);
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    logEvent('ArrowLeft', 'move_chunk_left');
                    moveChunk(0, -1);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    logEvent('ArrowRight', 'move_chunk_right');
                    moveChunk(0, 1);
                    break;
                case ' ':
                    e.preventDefault();
                    logEvent('Space', 'cycle_chunk');
                    cycleChunk();
                    break;
                case 'b':
                case 'B':
                    e.preventDefault();
                    logEvent('B', 'attempt_move_car');
                    moveCar();
                    break;
                case 'r':
                case 'R':
                    e.preventDefault();
                    logEvent('R', 'restart_level');
                    loadLevel(currentLevelIndex);
                    break;
            }
        });

        // Restart button
        document.getElementById('restart-button').addEventListener('click', () => {
            currentLevelIndex = 0;
            document.getElementById('restart-button').style.display = 'none';
            document.getElementById('download-button').style.display = 'none';

            // Reset session data
            sessionData = {
                sessionStart: new Date().toISOString(),
                events: []
            };

            loadLevel(currentLevelIndex);
        });

        // Download button
        document.getElementById('download-button').addEventListener('click', () => {
            sessionData.sessionEnd = new Date().toISOString();

            const dataStr = JSON.stringify(sessionData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `track-puzzle-session-${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Initialize game
        levels = [level1(), level2(), level3(), level4()];
        initGrid();
        loadLevel(0);
    </script>
</body>
</html>
