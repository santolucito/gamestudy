<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Shift</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #ffffff;
            color: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #game-container {
            text-align: center;
        }

        #instructions {
            font-size: 14px;
            margin-bottom: 30px;
            color: #888;
            max-width: 500px;
            line-height: 1.6;
        }

        #grid {
            display: inline-grid;
            grid-template-columns: repeat(9, 40px);
            grid-template-rows: repeat(9, 40px);
            gap: 2px;
            background: #e0e0e0;
            padding: 2px;
            border: 2px solid #e0e0e0;
            position: relative;
        }

        .pixel {
            width: 40px;
            height: 40px;
            background: #ffffff;
            transition: background-color 0.15s ease;
            position: relative;
        }

        .pixel.active {
            animation: pulse 0.3s ease;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        @keyframes ripple {
            0% {
                box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7),
                            0 0 0 0 rgba(34, 197, 94, 0.7);
            }
            50% {
                box-shadow: 0 0 0 15px rgba(34, 197, 94, 0.3),
                            0 0 0 30px rgba(34, 197, 94, 0.1);
            }
            100% {
                box-shadow: 0 0 0 30px rgba(34, 197, 94, 0),
                            0 0 0 60px rgba(34, 197, 94, 0);
            }
        }

        #grid.level-transition {
            animation: fadeIn 0.5s ease;
        }

        #grid.fade-out {
            animation: fadeOut 0.4s ease;
        }

        #grid.win-ripple {
            animation: ripple 0.8s ease-out;
        }

        #restart-btn {
            margin-top: 30px;
            padding: 12px 32px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            background: #10b981;
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            display: none;
        }

        #restart-btn:hover {
            background: #059669;
            transform: scale(1.05);
        }

        #restart-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="instructions">There are no instructions for this game, intentionally. Using the "U" and "J" keys, play the game to discover controls, rules, and the objective.</div>
        <div id="grid"></div>
        <button id="restart-btn">Restart</button>
    </div>

    <script>
        // Level color configuration
        const levelColors = {
            level1: '#3b82f6',  // blue
            level2: '#fbbf24',  // yellow
            level3: '#ef4444',  // red
            level4: '#10b981'   // green
        };

        // Game state
        let gameState = {
            currentLevel: 1,
            overlayOffset: { x: 0, y: 0 },
            targetPattern: [],
            overlayPattern: [],
            gridSize: 9,
            animating: false
        };

        // Data logging
        let logData = [];
        let sessionStart = new Date().toISOString();

        // Level 1: Plus sign (+), horizontal movement (U = left, J = right)
        function level1() {
            return {
                id: 1,
                color: levelColors.level1,
                movementType: 'horizontal',
                // TARGET PATTERN - Edit this to change the objective shape
                targetPattern: [
                    [0, 0, 0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 1, 0, 0, 0, 0],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [0, 0, 0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 1, 0, 0, 0, 0]
                ],
                // Hint pieces (static, always visible)
                hintPattern: [
                    [0, 0, 0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 1, 0, 0, 0, 0]
                ],
                // Overlay pieces (movable layer)
                overlayPattern: [
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [1, 1, 1, 1, 0, 1, 1, 1, 1],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0]
                ],
                initialOffset: { x: 2, y: 0 }  // Start offset 2 pixels to the right
            };
        }

        // Level 2: Semi-circle, diagonal movement (U = up-left, J = down-right)
        function level2() {
            return {
                id: 2,
                color: levelColors.level2,
                movementType: 'diagonal1',
                // TARGET PATTERN - Edit this to change the objective shape
                targetPattern: [
                    [0, 0, 0, 1, 1, 1, 0, 0, 0],
                    [0, 0, 1, 1, 1, 1, 1, 0, 0],
                    [0, 1, 1, 1, 1, 1, 1, 1, 0],
                    [1, 1, 1, 0, 0, 0, 1, 1, 1],
                    [1, 1, 0, 0, 0, 0, 0, 1, 1],
                    [1, 1, 0, 0, 0, 0, 0, 1, 1],
                    [1, 1, 0, 0, 0, 0, 0, 1, 1],
                    [1, 1, 0, 0, 0, 0, 0, 1, 1],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0]
                ],
                // Hint pieces (bottom half)
                hintPattern: [
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [1, 1, 0, 0, 0, 0, 0, 1, 1],
                    [1, 1, 0, 0, 0, 0, 0, 1, 1],
                    [1, 1, 0, 0, 0, 0, 0, 1, 1],
                    [1, 1, 0, 0, 0, 0, 0, 1, 1],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0]
                ],
                // Overlay pieces (top half)
                overlayPattern: [
                    [0, 0, 0, 1, 1, 1, 0, 0, 0],
                    [0, 0, 1, 1, 1, 1, 1, 0, 0],
                    [0, 1, 1, 1, 1, 1, 1, 1, 0],
                    [1, 1, 1, 0, 0, 0, 1, 1, 1],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0]
                ],
                initialOffset: { x: -1, y: -1 }  // Start offset diagonally
            };
        }

        // Level 3: Heart, vertical movement (U = up, J = down)
        function level3() {
            return {
                id: 3,
                color: levelColors.level3,
                movementType: 'vertical',
                // TARGET PATTERN - Edit this to change the objective shape
                targetPattern: [
                    [0, 0, 1, 1, 0, 1, 1, 0, 0],
                    [0, 1, 1, 1, 1, 1, 1, 1, 0],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [0, 1, 1, 1, 1, 1, 1, 1, 0],
                    [0, 0, 1, 1, 1, 1, 1, 0, 0],
                    [0, 0, 0, 1, 1, 1, 0, 0, 0],
                    [0, 0, 0, 0, 1, 0, 0, 0, 0]
                ],
                // Hint pieces (bottom half of heart)
                hintPattern: [
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [0, 1, 1, 1, 1, 1, 1, 1, 0],
                    [0, 0, 1, 1, 1, 1, 1, 0, 0],
                    [0, 0, 0, 1, 1, 1, 0, 0, 0],
                    [0, 0, 0, 0, 1, 0, 0, 0, 0]
                ],
                // Overlay pieces (top half of heart)
                overlayPattern: [
                    [0, 0, 1, 1, 0, 1, 1, 0, 0],
                    [0, 1, 1, 1, 1, 1, 1, 1, 0],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0]
                ],
                initialOffset: { x: 0, y: -2 }  // Start offset 2 pixels up
            };
        }

        // Level 4: Star (placeholder - you can modify this later)
        function level4() {
            return {
                id: 4,
                color: levelColors.level4,
                movementType: 'diagonal2',
                // TARGET PATTERN - Edit this to change the objective shape
                targetPattern: [
                    [0, 0, 0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 1, 1, 1, 0, 0, 0],
                    [0, 0, 0, 1, 1, 1, 0, 0, 0],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [0, 1, 1, 1, 1, 1, 1, 1, 0],
                    [0, 1, 1, 1, 0, 1, 1, 1, 0],
                    [1, 1, 1, 0, 0, 0, 1, 1, 1],
                    [1, 1, 0, 0, 0, 0, 0, 1, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 1]
                ],
                // Hint pieces (left half)
                hintPattern: [
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [1, 1, 1, 1, 1, 0, 0, 0, 0],
                    [0, 1, 1, 1, 1, 0, 0, 0, 0],
                    [0, 1, 1, 1, 0, 0, 0, 0, 0],
                    [1, 1, 1, 0, 0, 0, 0, 0, 0],
                    [1, 1, 0, 0, 0, 0, 0, 0, 0],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0]
                ],
                // Overlay pieces (top-right)
                overlayPattern: [
                    [0, 0, 0, 0, 1, 0, 0, 0, 0],
                    [0, 0, 0, 1, 1, 1, 0, 0, 0],
                    [0, 0, 0, 1, 1, 1, 0, 0, 0],
                    [0, 0, 0, 0, 0, 1, 1, 1, 1],
                    [0, 0, 0, 0, 0, 1, 1, 1, 0],
                    [0, 0, 0, 0, 0, 1, 1, 1, 0],
                    [0, 0, 0, 0, 0, 0, 1, 1, 1],
                    [0, 0, 0, 0, 0, 0, 0, 1, 1],
                    [0, 0, 0, 0, 0, 0, 0, 0, 1]
                ],
                initialOffset: { x: 1, y: -1 }  // Start offset diagonally opposite
            };
        }

        // Get level data
        function getLevelData(levelNum) {
            switch(levelNum) {
                case 1: return level1();
                case 2: return level2();
                case 3: return level3();
                case 4: return level4();
                default: return null;
            }
        }

        // Initialize grid display
        function initGrid() {
            const gridElement = document.getElementById('grid');
            gridElement.innerHTML = '';

            for (let i = 0; i < gameState.gridSize * gameState.gridSize; i++) {
                const pixel = document.createElement('div');
                pixel.className = 'pixel';
                pixel.dataset.index = i;
                gridElement.appendChild(pixel);
            }
        }

        // Render the current state
        function render() {
            const pixels = document.querySelectorAll('.pixel');
            const levelData = getLevelData(gameState.currentLevel);

            pixels.forEach((pixel, index) => {
                const x = index % gameState.gridSize;
                const y = Math.floor(index / gameState.gridSize);

                // Check if hint pixel should be shown (static layer)
                const isHintActive = levelData.hintPattern[y][x] === 1;

                // Calculate overlay position
                const overlayX = x - gameState.overlayOffset.x;
                const overlayY = y - gameState.overlayOffset.y;

                // Check if overlay pixel should be shown (movable layer)
                let isOverlayActive = false;
                if (overlayX >= 0 && overlayX < gameState.gridSize &&
                    overlayY >= 0 && overlayY < gameState.gridSize) {
                    isOverlayActive = levelData.overlayPattern[overlayY][overlayX] === 1;
                }

                // Render priority: overlay (full color) > hint (dimmed color) > background
                if (isOverlayActive) {
                    pixel.style.backgroundColor = levelData.color;
                    pixel.style.opacity = '1';
                } else if (isHintActive) {
                    pixel.style.backgroundColor = levelData.color;
                    pixel.style.opacity = '0.3';
                } else {
                    pixel.style.backgroundColor = '#ffffff';
                    pixel.style.opacity = '1';
                }
            });
        }

        // Check if overlay matches target (i.e., offset is 0,0)
        function checkWin() {
            return gameState.overlayOffset.x === 0 && gameState.overlayOffset.y === 0;
        }

        // Move overlay based on key and level's movement type
        function moveOverlay(key) {
            if (gameState.animating) return;

            const levelData = getLevelData(gameState.currentLevel);
            let dx = 0, dy = 0;
            let direction = '';

            switch(levelData.movementType) {
                case 'horizontal':
                    if (key === 'u') { dx = -1; direction = 'left'; }
                    if (key === 'j') { dx = 1; direction = 'right'; }
                    break;
                case 'vertical':
                    if (key === 'u') { dy = -1; direction = 'up'; }
                    if (key === 'j') { dy = 1; direction = 'down'; }
                    break;
                case 'diagonal1':
                    if (key === 'u') { dx = -1; dy = -1; direction = 'diagonal-up-left'; }
                    if (key === 'j') { dx = 1; dy = 1; direction = 'diagonal-down-right'; }
                    break;
                case 'diagonal2':
                    if (key === 'u') { dx = 1; dy = -1; direction = 'diagonal-up-right'; }
                    if (key === 'j') { dx = -1; dy = 1; direction = 'diagonal-down-left'; }
                    break;
            }

            if (dx === 0 && dy === 0) return;

            // Log the movement
            logMovement(key, direction, dx, dy);

            // Animate
            gameState.animating = true;
            gameState.overlayOffset.x += dx;
            gameState.overlayOffset.y += dy;

            render();

            setTimeout(() => {
                gameState.animating = false;

                // Check win condition
                if (checkWin()) {
                    advanceLevel();
                }
            }, 150);
        }

        // Advance to next level
        function advanceLevel() {
            const gridElement = document.getElementById('grid');

            // Trigger green ripple effect
            gridElement.classList.add('win-ripple');

            setTimeout(() => {
                gridElement.classList.remove('win-ripple');

                // Check if there's a next level
                const nextLevelData = getLevelData(gameState.currentLevel + 1);

                if (nextLevelData) {
                    // Fade out current level
                    gridElement.classList.add('fade-out');

                    setTimeout(() => {
                        gameState.currentLevel++;
                        gameState.overlayOffset = { ...nextLevelData.initialOffset };

                        gridElement.classList.remove('fade-out');
                        gridElement.classList.add('level-transition');
                        setTimeout(() => gridElement.classList.remove('level-transition'), 500);

                        render();
                    }, 400);
                } else {
                    // Game complete - show restart button
                    setTimeout(() => {
                        document.getElementById('restart-btn').style.display = 'inline-block';
                    }, 300);
                }
            }, 800);
        }

        // Restart game
        function restartGame() {
            gameState.currentLevel = 1;
            const firstLevel = getLevelData(1);
            gameState.overlayOffset = { ...firstLevel.initialOffset };
            document.getElementById('restart-btn').style.display = 'none';

            const gridElement = document.getElementById('grid');
            gridElement.classList.add('level-transition');
            setTimeout(() => gridElement.classList.remove('level-transition'), 500);

            render();
        }

        // Log movement data
        function logMovement(key, direction, dx, dy) {
            const movementData = {
                timestamp: new Date().toISOString(),
                sessionStart: sessionStart,
                level: gameState.currentLevel,
                eventType: 'keypress',
                key: key,
                direction: direction,
                overlayPositionBefore: {
                    x: gameState.overlayOffset.x,
                    y: gameState.overlayOffset.y
                },
                overlayPositionAfter: {
                    x: gameState.overlayOffset.x + dx,
                    y: gameState.overlayOffset.y + dy
                },
                delta: { dx, dy }
            };
            logData.push(movementData);
        }

        // Save log data as JSON file
        function saveLogData() {
            const dataStr = JSON.stringify(logData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `pixel-shift-log-${new Date().toISOString()}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        // Alternative: Send log data to server
        function sendLogData(serverUrl) {
            fetch(serverUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    sessionStart: sessionStart,
                    sessionEnd: new Date().toISOString(),
                    movements: logData
                })
            })
            .then(response => response.json())
            .then(data => console.log('Log data sent successfully:', data))
            .catch(error => console.error('Error sending log data:', error));
        }

        // Keyboard event handler
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            if (key === 'u' || key === 'j') {
                e.preventDefault();
                moveOverlay(key);
            }

            // Secret key to save log data: press 's'
            if (key === 's') {
                saveLogData();
            }
        });

        // Restart button event handler
        document.getElementById('restart-btn').addEventListener('click', restartGame);

        // Initialize game
        function initGame() {
            const firstLevel = getLevelData(1);
            gameState.overlayOffset = { ...firstLevel.initialOffset };
            initGrid();
            render();
        }

        // Start the game
        initGame();
    </script>
</body>
</html>
