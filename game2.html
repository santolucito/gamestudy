<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Game 2</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Trebuchet MS', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: #fff;
            color: #1a1a1a;
            padding: 20px;
        }

        #instructions {
            text-align: center;
            margin-bottom: 30px;
            max-width: 600px;
            line-height: 1.6;
        }

        #instructions p {
            margin: 5px 0;
        }

        #game-container {
            position: relative;
        }

        #grid {
            display: grid;
            gap: 2px;
            background: #e0e0e0;
            padding: 2px;
            border: 3px solid #e0e0e0;
            position: relative;
            opacity: 1;
            transition: opacity 0.5s ease-in-out;
        }

        .cell {
            width: 40px;
            height: 40px;
            background: #fff;
            position: relative;
            transition: background-color 0.2s;
        }

        .cell.avatar {
            border: 3px solid #1a1a1a57;
            background: #1a1a1a57
        }

        .cell.dock {
            border: 4px solid #000;
        }

        #restart-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            font-size: 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            display: none;
        }

        #restart-btn:hover {
            background: #45a049;
        }

        #download-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            font-size: 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }

        #download-btn:hover {
            background: #0b7dda;
        }

        @keyframes ripple {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        .ripple-effect {
            animation: ripple 0.6s ease-out;
            position: absolute;
            border-radius: 50%;
            border: 7px solid #32CD32;
            opacity: 2;
        }
    </style>
</head>
<body>
    <button id="restart-btn">Restart</button>
    <button id="download-btn">Download Data</button>

    <div id="instructions">
        <p>There are no instructions for this game, intentionally.</p>
        <p>Using the arrow keys, play the game to discover controls, rules, and the objective.</p>
    </div>

    <div id="game-container">
        <div id="grid"></div>
    </div>

    <script>
        // ============================
        // COLOR PALETTE
        // ============================
        const COLORS = {
            gray: "#D3D3D3",
            blue: "#ADD8E6",
            yellow: "#DDCC77",
            teal: "#44AA99",
            pink: "#CC6677",
            violet: "#332288",
            lime: "#BBCC33",
            magenta: "#882255",
            blue2: "#88CCEE",
            black: "#000000",
            white: "#FFFFFF",
            lavender: "#E0CCF5"
        };

        // ============================
        // LEVEL DEFINITIONS
        // ============================
        const LEVELS = {
            1: {
                boardSize: 8,
                avatarStart: {x: 0, y: 0},
                spawnDockCells: [{x: 0, y: 0}],
                spawnTriggerCell: {x: 0, y: 0},
                spawnAdjacencyRequirement: 0,
                spawnRemoverDockCells: [{x: 7, y: 0}],
                spawnRemoverTriggerCell: {x: 7, y: 0},
                spawnRemoverAdjacencyRequirement: 0,
                hintTemplateCells: [
                    {x: 3, y: 4, color: COLORS.lavender},
                ],
                initialStaticPieces: [],
                spawnSequence: [
                    {x: 0, y: 7, color: COLORS.pink},
                    {x: 7, y: 7, color: COLORS.blue},
                    {x: 2, y: 5, color: COLORS.lime},
                    {x: 5, y: 1, color: COLORS.lavender}
                ],
                goalPattern: [
                    {x: 3, y: 3, requiredColor: COLORS.violet},
                    {x: 3, y: 4, requiredColor: COLORS.violet},
                    {x: 4, y: 3, requiredColor: COLORS.violet},
                    {x: 4, y: 4, requiredColor: COLORS.violet}
                ],
                palette: {avatarDefault: COLORS.gray, spawnDock: COLORS.black, triggerCell: COLORS.white}
            },
            2: {
                boardSize: 8,
                avatarStart: {x: 4, y: 4},
                spawnDockCells: [{x: 0, y: 0}],
                spawnTriggerCell: {x: 0, y: 0},
                spawnAdjacencyRequirement: 0,
                spawnRemoverDockCells: [{x: 7, y: 0}],
                spawnRemoverTriggerCell: {x: 7, y: 0},
                spawnRemoverAdjacencyRequirement: 0,
                hintTemplateCells: [
                    {x: 2, y: 2, color: COLORS.violet},
                    {x: 3, y: 2, color: COLORS.violet},
                    {x: 4, y: 2, color: COLORS.violet},
                    {x: 4, y: 3, color: COLORS.violet},
                    {x: 4, y: 5, color: COLORS.violet},
                    {x: 5, y: 2, color: COLORS.violet},
                    {x: 5, y: 3, color: COLORS.violet},
                    {x: 5, y: 4, color: COLORS.violet},
                    {x: 5, y: 5, color: COLORS.violet}
                ],
                initialStaticPieces: [],
                spawnSequence: [
                    {x: 3, y: 3, color: COLORS.yellow},
                    {x: 2, y: 2, color: COLORS.yellow},
                    {x: 5, y: 5, color: COLORS.blue2},
                    {x: 5, y: 6, color: COLORS.blue2},
                    {x: 6, y: 5, color: COLORS.blue2},
                    {x: 4, y: 7, color: COLORS.blue2}
                ],
                goalPattern: [
                    {x: 6, y: 6, requiredColor: COLORS.blue2},
                    {x: 6, y: 7, requiredColor: COLORS.blue2},
                    {x: 7, y: 6, requiredColor: COLORS.blue2},
                    {x: 7, y: 7, requiredColor: COLORS.blue2}
                ],
                palette: {avatarDefault: COLORS.gray, spawnDock: COLORS.black, triggerCell: COLORS.white}
            },
            3: {
                boardSize: 8,
                avatarStart: {x: 3, y: 3},
                spawnDockCells: [{x: 0, y: 0}],
                spawnTriggerCell: {x: 0, y: 0},
                spawnAdjacencyRequirement: 0,
                spawnRemoverDockCells: [{x: 7, y: 0}],
                spawnRemoverTriggerCell: {x: 7, y: 0},
                spawnRemoverAdjacencyRequirement: 0,
                hintTemplateCells: [
                    {x: 1, y: 1, color: COLORS.yellow},
                    {x: 1, y: 2, color: COLORS.yellow},
                    {x: 2, y: 1, color: COLORS.yellow},
                    {x: 2, y: 2, color: COLORS.yellow},
                    {x: 5, y: 5, color: COLORS.lime},
                    {x: 5, y: 6, color: COLORS.lime}
                ],
                initialStaticPieces: [],
                spawnSequence: [
                    {x: 4, y: 4, color: COLORS.lime},
                    {x: 3, y: 5, color: COLORS.lime},
                    {x: 2, y: 3, color: COLORS.yellow},
                    {x: 0, y: 1, color: COLORS.yellow},
                    {x: 0, y: 2, color: COLORS.yellow},
                    {x: 1, y: 3, color: COLORS.yellow},
                    {x: 6, y: 5, color: COLORS.lime},
                    {x: 4, y: 6, color: COLORS.lime}
                ],
                goalPattern: [
                    {x: 1, y: 1, requiredColor: COLORS.yellow},
                    {x: 1, y: 2, requiredColor: COLORS.yellow},
                    {x: 2, y: 1, requiredColor: COLORS.yellow},
                    {x: 2, y: 2, requiredColor: COLORS.yellow},
                    {x: 5, y: 5, requiredColor: COLORS.lime},
                    {x: 5, y: 6, requiredColor: COLORS.lime}
                ],
                palette: {avatarDefault: COLORS.gray, spawnDock: COLORS.black, triggerCell: COLORS.white}
            },
            4: {
                boardSize: 8,
                avatarStart: {x: 0, y: 0},
                spawnDockCells: [{x: 0, y: 0}],
                spawnTriggerCell: {x: 0, y: 0},
                spawnAdjacencyRequirement: 0,
                spawnRemoverDockCells: [{x: 7, y: 0}],
                spawnRemoverTriggerCell: {x: 7, y: 0},
                spawnRemoverAdjacencyRequirement: 0,
                hintTemplateCells: [
                    {x: 0, y: 0, color: COLORS.magenta},
                    {x: 1, y: 0, color: COLORS.magenta},
                    {x: 0, y: 1, color: COLORS.magenta},
                    {x: 7, y: 0, color: COLORS.teal},
                    {x: 7, y: 1, color: COLORS.teal}
                ],
                initialStaticPieces: [],
                spawnSequence: [
                    {x: 2, y: 6, color: COLORS.pink},
                    {x: 5, y: 5, color: COLORS.pink},
                    {x: 1, y: 1, color: COLORS.magenta},
                    {x: 2, y: 0, color: COLORS.magenta},
                    {x: 0, y: 2, color: COLORS.magenta},
                    {x: 6, y: 0, color: COLORS.teal},
                    {x: 6, y: 1, color: COLORS.teal},
                    {x: 7, y: 2, color: COLORS.teal}
                ],
                goalPattern: [
                    {x: 0, y: 0, requiredColor: COLORS.magenta},
                    {x: 1, y: 0, requiredColor: COLORS.magenta},
                    {x: 0, y: 1, requiredColor: COLORS.magenta},
                    {x: 7, y: 0, requiredColor: COLORS.teal},
                    {x: 7, y: 1, requiredColor: COLORS.teal}
                ],
                palette: {avatarDefault: COLORS.gray, spawnDock: COLORS.black, triggerCell: COLORS.white}
            },
            5: {
                boardSize: 8,
                avatarStart: {x: 4, y: 0},
                spawnDockCells: [{x: 0, y: 0}],
                spawnTriggerCell: {x: 0, y: 0},
                spawnAdjacencyRequirement: 0,
                spawnRemoverDockCells: [{x: 7, y: 0}],
                spawnRemoverTriggerCell: {x: 7, y: 0},
                spawnRemoverAdjacencyRequirement: 0,
                hintTemplateCells: [
                    {x: 5, y: 5, color: COLORS.yellow},
                    {x: 0, y: 0, color: COLORS.teal},
                    {x: 0, y: 5, color: COLORS.blue},
                    {x: 5, y: 0, color: COLORS.pink}
                ],
                initialStaticPieces: [],
                spawnSequence: [
                    {x: 2, y: 2, color: COLORS.pink},
                    {x: 3, y: 3, color: COLORS.pink},
                    {x: 1, y: 4, color: COLORS.blue},
                    {x: 0, y: 4, color: COLORS.blue},
                    {x: 4, y: 1, color: COLORS.pink},
                    {x: 4, y: 0, color: COLORS.pink},
                    {x: 4, y: 4, color: COLORS.yellow},
                    {x: 5, y: 4, color: COLORS.yellow}
                ],
                goalPattern: [
                    {x: 5, y: 5, requiredColor: COLORS.yellow},
                    {x: 0, y: 0, requiredColor: COLORS.teal},
                    {x: 0, y: 5, requiredColor: COLORS.blue},
                    {x: 5, y: 0, requiredColor: COLORS.pink}
                ],
                palette: {avatarDefault: COLORS.gray, spawnDock: COLORS.black, triggerCell: COLORS.white}
            }
        };

        // ============================
        // GAME STATE
        // ============================
        let currentLevel = 1;
        let avatar = {x: 0, y: 0, color: "gray"};
        let board = [];
        let spawnIndex = 0;
        let spawnHistory = [];
        let gameLog = [];
        let levelCompleted = false;

        // ============================
        // INITIALIZATION
        // ============================
        function initGame() {
            const level = LEVELS[currentLevel];
            avatar = {
                x: level.avatarStart.x,
                y: level.avatarStart.y,
                color: level.palette.avatarDefault
            };

            // Initialize empty board
            board = [];
            for (let x = 0; x < level.boardSize; x++) {
                board[x] = [];
                for (let y = 0; y < level.boardSize; y++) {
                    board[x][y] = {color: null, isTemplate: false, isGoal: false};
                }
            }

            // Place hint template cells
            level.hintTemplateCells.forEach(cell => {
                board[cell.x][cell.y] = {color: cell.color, isTemplate: true, isGoal: false};
            });

            // Place initial static pieces
            level.initialStaticPieces.forEach(piece => {
                board[piece.x][piece.y] = {color: piece.color, isTemplate: false, isGoal: false};
            });

            // Mark goal pattern cells
            level.goalPattern.forEach(goal => {
                board[goal.x][goal.y].isGoal = true;
            });

            spawnIndex = 0;
            spawnHistory = [];
            levelCompleted = false;

            logEvent({
                type: "level_start",
                level: currentLevel,
                timestamp: Date.now()
            });

            renderBoard();
        }

        // ============================
        // RENDERING
        // ============================
        function renderBoard() {
            const level = LEVELS[currentLevel];
            const gridElement = document.getElementById('grid');
            gridElement.style.gridTemplateColumns = `repeat(${level.boardSize}, 40px)`;
            gridElement.innerHTML = '';

            // Render from top to bottom of screen (high y to low y in math coordinates)
            // Mathematical graph: (0,0) = bottom-left, board[x][y] where x=column, y=row
            for (let screenRow = 0; screenRow < level.boardSize; screenRow++) {
                const y = level.boardSize - 1 - screenRow;  // flip y-axis for math graph
                for (let x = 0; x < level.boardSize; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';

                    // Determine cell color
                    let cellColor = '#fff';
                    const boardCell = board[x][y];

                    if (boardCell.color) {
                        cellColor = boardCell.color;
                    } else if (boardCell.isGoal) {
                        // Show grey background for empty goal cells (hint)
                        cellColor = COLORS.gray;
                    }

                    // Check if this is spawn dock
                    const isDock = level.spawnDockCells.some(dock => dock.x === x && dock.y === y);
                    if (isDock && !boardCell.color) {
                        cellColor = level.palette.spawnDock;
                        cell.classList.add('dock');
                    }

                    // Check if avatar is on this cell
                    const isAvatar = (avatar.x === x && avatar.y === y);

                    // Only show trigger/dock colors if avatar is NOT on this cell
                    if (!isAvatar) {
                        // Check if this is trigger cell
                        if (level.spawnTriggerCell.x === x && level.spawnTriggerCell.y === y && !boardCell.color) {
                            cellColor = level.palette.triggerCell;
                        }

                        // Check if this is spawn remover dock
                        if (level.spawnRemoverDockCells) {
                            const isRemoverDock = level.spawnRemoverDockCells.some(dock => dock.x === x && dock.y === y);
                            if (isRemoverDock && !boardCell.color) {
                                cellColor = level.palette.spawnDock;
                                cell.classList.add('dock');
                            }
                        }

                        // Check if this is spawn remover trigger cell
                        if (level.spawnRemoverTriggerCell && level.spawnRemoverTriggerCell.x === x && level.spawnRemoverTriggerCell.y === y && !boardCell.color) {
                            cellColor = level.palette.triggerCell;
                        }
                    }

                    cell.style.backgroundColor = cellColor;

                    // Draw avatar
                    if (isAvatar) {
                        cell.classList.add('avatar');
                        cell.style.backgroundColor = avatar.color;
                    }

                    gridElement.appendChild(cell);
                }
            }
        }

        // ============================
        // MOVEMENT & GAME LOGIC
        // ============================
        function moveAvatar(dx, dy) {
            if (levelCompleted) return;

            const level = LEVELS[currentLevel];
            const newX = avatar.x + dx;
            const newY = avatar.y + dy;

            // Check bounds
            if (newX < 0 || newX >= level.boardSize || newY < 0 || newY >= level.boardSize) {
                return;
            }

            // Check if target cell is blocked by ANY piece
            // Avatar can ONLY move onto the two dock cells at (0,0) and (7,0) - everything else blocks
            // Mathematical graph: (0,0) = bottom-left, (7,0) = bottom-right
            const targetCell = board[newX][newY];
            const isOnSpawnDock = (newX === 0 && newY === 0);
            const isOnRemoverDock = (newX === 7 && newY === 0);
            const isOnDock = isOnSpawnDock || isOnRemoverDock;

            // Block if cell has ANY color (template, spawned, or deposited) and is NOT a dock
            if (targetCell.color && !isOnDock) {
                // Movement blocked - but check if avatar can pick up color from spawned piece
                if (!targetCell.isTemplate && avatar.color === level.palette.avatarDefault) {
                    // Avatar is not carrying anything - pick up the color (replaces current color)
                    avatar.color = targetCell.color;

                    logEvent({
                        type: "pickup",
                        position: {x: newX, y: newY},
                        color: avatar.color,
                        timestamp: Date.now()
                    });

                    renderBoard();
                    return; // Movement still blocked, but color picked up
                }

                // Just blocked, no pickup
                logEvent({
                    type: "move_blocked",
                    attemptedPosition: {x: newX, y: newY},
                    blockedBy: targetCell.color,
                    isTemplate: targetCell.isTemplate,
                    timestamp: Date.now()
                });
                return;
            }

            const oldX = avatar.x;
            const oldY = avatar.y;

            // Move avatar
            avatar.x = newX;
            avatar.y = newY;

            logEvent({
                type: "move",
                from: {x: oldX, y: oldY},
                to: {x: newX, y: newY},
                avatarColor: avatar.color,
                timestamp: Date.now()
            });

            // Check adjacent cells for pickup or deposit
            const directions = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];
            let actionTaken = false;

            for (const dir of directions) {
                const adjX = newX + dir.dx;
                const adjY = newY + dir.dy;

                if (adjX >= 0 && adjX < level.boardSize && adjY >= 0 && adjY < level.boardSize) {
                    const adjCell = board[adjX][adjY];

                    // Check if touching same color - DEPOSIT (works with any colored cell including templates)
                    if (adjCell.color === avatar.color && avatar.color !== level.palette.avatarDefault) {
                        // Deposit in current position and reset to gray
                        board[newX][newY].color = avatar.color;
                        avatar.color = level.palette.avatarDefault;
                        actionTaken = true;

                        logEvent({
                            type: "deposit",
                            position: {x: newX, y: newY},
                            color: board[newX][newY].color,
                            timestamp: Date.now()
                        });
                        break;
                    }
                }
            }

            // If didn't deposit, check for pickup
            if (!actionTaken) {
                for (const dir of directions) {
                    const adjX = newX + dir.dx;
                    const adjY = newY + dir.dy;

                    if (adjX >= 0 && adjX < level.boardSize && adjY >= 0 && adjY < level.boardSize) {
                        const adjCell = board[adjX][adjY];

                        // Check if touching a colored piece - PICKUP
                        if (!adjCell.isTemplate && adjCell.color) {
                            // Pick up this color (replaces current)
                            avatar.color = adjCell.color;

                            logEvent({
                                type: "pickup",
                                position: {x: adjX, y: adjY},
                                color: avatar.color,
                                timestamp: Date.now()
                            });
                            break;
                        }
                    }
                }
            }

            // Check spawn trigger
            if (newX === level.spawnTriggerCell.x && newY === level.spawnTriggerCell.y) {
                checkAndSpawn();
            }

            // Check spawn remover trigger
            if (level.spawnRemoverTriggerCell && newX === level.spawnRemoverTriggerCell.x && newY === level.spawnRemoverTriggerCell.y) {
                checkAndRemoveSpawn();
            }

            renderBoard();
            checkWinCondition();
        }

        function hasOrthogonalNeighborWithColor(x, y, color) {
            const level = LEVELS[currentLevel];
            const directions = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];

            for (const dir of directions) {
                const nx = x + dir.dx;
                const ny = y + dir.dy;

                if (nx >= 0 && nx < level.boardSize && ny >= 0 && ny < level.boardSize) {
                    if (board[nx][ny].color === color) {
                        return true;
                    }
                }
            }

            return false;
        }

        function checkAndSpawn() {
            const level = LEVELS[currentLevel];
            const trigger = level.spawnTriggerCell;

            // Count adjacent dock cells
            let adjacentDockCount = 0;
            const directions = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];

            for (const dir of directions) {
                const nx = trigger.x + dir.dx;
                const ny = trigger.y + dir.dy;

                if (level.spawnDockCells.some(dock => dock.x === nx && dock.y === ny)) {
                    adjacentDockCount++;
                }
            }

            logEvent({
                type: "spawn_trigger_check",
                position: {x: trigger.x, y: trigger.y},
                adjacentDockCount: adjacentDockCount,
                required: level.spawnAdjacencyRequirement,
                timestamp: Date.now()
            });

            if (adjacentDockCount >= level.spawnAdjacencyRequirement) {
                attemptSpawn();
            }
        }

        function attemptSpawn() {
            const level = LEVELS[currentLevel];

            if (spawnIndex >= level.spawnSequence.length) {
                logEvent({
                    type: "spawn_exhausted",
                    timestamp: Date.now()
                });
                return;
            }

            // Try to spawn pieces in sequence
            let spawned = false;
            let attempts = 0;

            while (!spawned && spawnIndex < level.spawnSequence.length && attempts < level.spawnSequence.length) {
                const spawn = level.spawnSequence[spawnIndex];
                const targetCell = board[spawn.x][spawn.y];

                if (!targetCell.color && !targetCell.isTemplate) {
                    // Spawn successful
                    board[spawn.x][spawn.y].color = spawn.color;
                    spawnHistory.push({
                        index: spawnIndex,
                        position: {x: spawn.x, y: spawn.y},
                        color: spawn.color,
                        timestamp: Date.now()
                    });

                    logEvent({
                        type: "spawn_placed",
                        spawnIndex: spawnIndex,
                        position: {x: spawn.x, y: spawn.y},
                        color: spawn.color,
                        timestamp: Date.now()
                    });

                    spawnIndex++;
                    spawned = true;
                } else {
                    // Cell occupied, skip to next
                    logEvent({
                        type: "spawn_skipped",
                        spawnIndex: spawnIndex,
                        position: {x: spawn.x, y: spawn.y},
                        reason: "cell_occupied",
                        timestamp: Date.now()
                    });

                    spawnIndex++;
                    attempts++;
                }
            }
        }

        function checkAndRemoveSpawn() {
            const level = LEVELS[currentLevel];
            if (!level.spawnRemoverTriggerCell) return;

            const trigger = level.spawnRemoverTriggerCell;

            // Count adjacent spawn remover dock cells
            let adjacentDockCount = 0;
            const directions = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];

            for (const dir of directions) {
                const nx = trigger.x + dir.dx;
                const ny = trigger.y + dir.dy;

                if (level.spawnRemoverDockCells.some(dock => dock.x === nx && dock.y === ny)) {
                    adjacentDockCount++;
                }
            }

            logEvent({
                type: "spawn_remover_trigger_check",
                position: {x: trigger.x, y: trigger.y},
                adjacentDockCount: adjacentDockCount,
                required: level.spawnRemoverAdjacencyRequirement,
                timestamp: Date.now()
            });

            if (adjacentDockCount >= level.spawnRemoverAdjacencyRequirement) {
                // Remove the most recent spawn
                if (spawnHistory.length > 0) {
                    const lastSpawn = spawnHistory.pop();
                    board[lastSpawn.position.x][lastSpawn.position.y].color = null;

                    logEvent({
                        type: "spawn_removed",
                        position: lastSpawn.position,
                        color: lastSpawn.color,
                        timestamp: Date.now()
                    });

                    spawnIndex--;
                    renderBoard();
                }
            }
        }

        // ============================
        // WIN CONDITION
        // ============================
        function checkWinCondition() {
            const level = LEVELS[currentLevel];
            let allMatch = true;

            for (const goal of level.goalPattern) {
                const cell = board[goal.x][goal.y];
                if (cell.color !== goal.requiredColor) {
                    allMatch = false;
                    break;
                }
            }

            if (allMatch && !levelCompleted) {
                levelCompleted = true;

                logEvent({
                    type: "level_complete",
                    level: currentLevel,
                    timestamp: Date.now()
                });

                triggerWin();
            }
        }

        function triggerWin() {
            // Ripple effect
            const grid = document.getElementById('grid');
            grid.classList.add('ripple-effect');

            setTimeout(() => {
                grid.classList.remove('ripple-effect');

                // Auto-advance to next level or show restart button
                if (currentLevel === 5) {
                    // Show restart button after completing level 5
                    document.getElementById('restart-btn').style.display = "block";
                } else {
                    // Auto-advance to next level
                    currentLevel++;
                    initGame();
                }
            }, 600);
        }

        // ============================
        // LOGGING
        // ============================
        function logEvent(event) {
            gameLog.push(event);
        }

        function downloadData() {
            const data = {
                currentLevel: currentLevel,
                gameLog: gameLog,
                spawnHistory: spawnHistory,
                exportTime: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `game-data-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            logEvent({
                type: "data_downloaded",
                timestamp: Date.now()
            });
        }

        // ============================
        // EVENT LISTENERS
        // ============================
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    moveAvatar(0, 1); // increase y (move up in math graph)
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    moveAvatar(0, -1); // decrease y (move down in math graph)
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    moveAvatar(-1, 0); // decrease x (move left)
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    moveAvatar(1, 0); // increase x (move right)
                    break;
            }
        });

        document.getElementById('download-btn').addEventListener('click', downloadData);

        document.getElementById('restart-btn').addEventListener('click', () => {
            currentLevel = 1;
            document.getElementById('restart-btn').style.display = "none";
            initGame();
        });

        // ============================
        // START GAME
        // ============================
        initGame();
    </script>
</body>
</html>