<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Color Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: #1a1a1a;
            color: #fff;
            padding: 20px;
        }

        #instructions {
            text-align: center;
            margin-bottom: 30px;
            max-width: 600px;
            line-height: 1.6;
        }

        #instructions p {
            margin: 5px 0;
        }

        #game-container {
            position: relative;
        }

        #grid {
            display: grid;
            gap: 2px;
            background: #333;
            padding: 2px;
            border: 3px solid #555;
            position: relative;
        }

        .cell {
            width: 40px;
            height: 40px;
            background: #222;
            position: relative;
            transition: background-color 0.2s;
        }

        .cell.avatar {
            border: 3px solid #fff;
        }

        #restart-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            font-size: 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            display: none;
        }

        #restart-btn:hover {
            background: #45a049;
        }

        #download-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            font-size: 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }

        #download-btn:hover {
            background: #0b7dda;
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 1000;
        }

        #overlay.show {
            display: flex;
        }

        #overlay h2 {
            font-size: 48px;
            margin-bottom: 20px;
            animation: fadeIn 0.5s;
        }

        #next-level-btn {
            padding: 15px 30px;
            font-size: 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            margin-top: 20px;
        }

        #next-level-btn:hover {
            background: #45a049;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 1; transform: scale(1); }
        }

        @keyframes ripple {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        .ripple-effect {
            animation: ripple 0.6s ease-out;
        }
    </style>
</head>
<body>
    <button id="restart-btn">Restart</button>
    <button id="download-btn">Download Data</button>

    <div id="instructions">
        <p>There are no instructions for this game, intentionally.</p>
        <p>Using the arrow keys, play the game to discover controls, rules, and the objective.</p>
    </div>

    <div id="game-container">
        <div id="grid"></div>
    </div>

    <div id="overlay">
        <h2 id="overlay-message">Level Complete!</h2>
        <button id="next-level-btn">Next Level</button>
    </div>

    <script>
        // ============================
        // LEVEL DEFINITIONS
        // ============================
        const LEVELS = {
            1: {
                boardSize: 8,
                avatarStart: {x: 0, y: 0},
                spawnDockCells: [{x: 0, y: 6}, {x: 0, y: 7}, {x: 1, y: 7}],
                spawnTriggerCell: {x: 1, y: 6},
                spawnAdjacencyRequirement: 2,
                hintTemplateCells: [
                    {x: 2, y: 2, color: "purple"},
                    {x: 2, y: 2, color: "purple"},
                    {x: 3, y: 3, color: "purple"},
                    {x: 4, y: 2, color: "purple"},
                    {x: 4, y: 3, color: "purple"},
                    {x: 4, y: 4, color: "purple"},
                    {x: 4, y: 5, color: "purple"},
                    {x: 5, y: 2, color: "purple"},
                    {x: 5, y: 3, color: "purple"},
                    {x: 5, y: 4, color: "purple"},
                    {x: 5, y: 5, color: "purple"}
                ],
                initialStaticPieces: [{x: 1, y: 6, color: "white"}],
                spawnSequence: [
                    {x: 5, y: 4, color: "red"},
                    {x: 1, y: 1, color: "blue"},
                    {x: 6, y: 6, color: "red"},
                    {x: 4, y: 1, color: "blue"},
                    {x: 7, y: 5, color: "purple"},
                    {x: 6, y: 2, color: "purple"}
                ],
                goalPattern: [
                    {x: 2, y: 2, requiredColor: "purple"},
                    {x: 2, y: 3, requiredColor: "purple"},
                    {x: 3, y: 2, requiredColor: "purple"},
                    {x: 3, y: 3, requiredColor: "purple"}
                ],
                palette: {avatarDefault: "gray", spawnDock: "black", triggerCell: "white"}
            },
            2: {
                boardSize: 8,
                avatarStart: {x: 4, y: 4},
                spawnDockCells: [{x: 0, y: 0}, {x: 0, y: 1}, {x: 1, y: 0}],
                spawnTriggerCell: {x: 1, y: 1},
                spawnAdjacencyRequirement: 2,
                hintTemplateCells: [
                    {x: 6, y: 6, color: "cyan"},
                    {x: 6, y: 7, color: "cyan"},
                    {x: 7, y: 6, color: "cyan"},
                    {x: 7, y: 7, color: "cyan"}
                ],
                initialStaticPieces: [{x: 1, y: 1, color: "white"}],
                spawnSequence: [
                    {x: 3, y: 3, color: "yellow"},
                    {x: 2, y: 2, color: "yellow"},
                    {x: 5, y: 5, color: "cyan"},
                    {x: 5, y: 6, color: "cyan"},
                    {x: 6, y: 5, color: "cyan"},
                    {x: 4, y: 7, color: "cyan"}
                ],
                goalPattern: [
                    {x: 6, y: 6, requiredColor: "cyan"},
                    {x: 6, y: 7, requiredColor: "cyan"},
                    {x: 7, y: 6, requiredColor: "cyan"},
                    {x: 7, y: 7, requiredColor: "cyan"}
                ],
                palette: {avatarDefault: "gray", spawnDock: "black", triggerCell: "white"}
            },
            3: {
                boardSize: 8,
                avatarStart: {x: 3, y: 3},
                spawnDockCells: [{x: 7, y: 0}, {x: 7, y: 1}, {x: 6, y: 0}],
                spawnTriggerCell: {x: 6, y: 1},
                spawnAdjacencyRequirement: 2,
                hintTemplateCells: [
                    {x: 1, y: 1, color: "orange"},
                    {x: 1, y: 2, color: "orange"},
                    {x: 2, y: 1, color: "orange"},
                    {x: 2, y: 2, color: "orange"},
                    {x: 5, y: 5, color: "lime"},
                    {x: 5, y: 6, color: "lime"}
                ],
                initialStaticPieces: [{x: 6, y: 1, color: "white"}],
                spawnSequence: [
                    {x: 4, y: 4, color: "green"},
                    {x: 3, y: 5, color: "green"},
                    {x: 2, y: 3, color: "orange"},
                    {x: 0, y: 1, color: "orange"},
                    {x: 0, y: 2, color: "orange"},
                    {x: 1, y: 3, color: "orange"},
                    {x: 6, y: 5, color: "lime"},
                    {x: 4, y: 6, color: "lime"}
                ],
                goalPattern: [
                    {x: 1, y: 1, requiredColor: "orange"},
                    {x: 1, y: 2, requiredColor: "orange"},
                    {x: 2, y: 1, requiredColor: "orange"},
                    {x: 2, y: 2, requiredColor: "orange"},
                    {x: 5, y: 5, requiredColor: "lime"},
                    {x: 5, y: 6, requiredColor: "lime"}
                ],
                palette: {avatarDefault: "gray", spawnDock: "black", triggerCell: "white"}
            },
            4: {
                boardSize: 8,
                avatarStart: {x: 0, y: 7},
                spawnDockCells: [{x: 3, y: 3}, {x: 3, y: 4}, {x: 4, y: 3}, {x: 4, y: 4}],
                spawnTriggerCell: {x: 3, y: 3},
                spawnAdjacencyRequirement: 3,
                hintTemplateCells: [
                    {x: 0, y: 0, color: "magenta"},
                    {x: 1, y: 0, color: "magenta"},
                    {x: 0, y: 1, color: "magenta"},
                    {x: 7, y: 0, color: "teal"},
                    {x: 7, y: 1, color: "teal"}
                ],
                initialStaticPieces: [{x: 3, y: 3, color: "white"}],
                spawnSequence: [
                    {x: 2, y: 6, color: "pink"},
                    {x: 5, y: 5, color: "pink"},
                    {x: 1, y: 1, color: "magenta"},
                    {x: 2, y: 0, color: "magenta"},
                    {x: 0, y: 2, color: "magenta"},
                    {x: 6, y: 0, color: "teal"},
                    {x: 6, y: 1, color: "teal"},
                    {x: 7, y: 2, color: "teal"}
                ],
                goalPattern: [
                    {x: 0, y: 0, requiredColor: "magenta"},
                    {x: 1, y: 0, requiredColor: "magenta"},
                    {x: 0, y: 1, requiredColor: "magenta"},
                    {x: 7, y: 0, requiredColor: "teal"},
                    {x: 7, y: 1, requiredColor: "teal"}
                ],
                palette: {avatarDefault: "gray", spawnDock: "black", triggerCell: "white"}
            },
            5: {
                boardSize: 8,
                avatarStart: {x: 4, y: 0},
                spawnDockCells: [{x: 0, y: 0}, {x: 5, y: 5}, {x: 0, y: 5}, {x: 5, y: 0}],
                spawnTriggerCell: {x: 0, y: 0},
                spawnAdjacencyRequirement: 1,
                hintTemplateCells: [
                    {x: 5, y: 5, color: "yellow"},
                    {x: 0, y: 0, color: "teal"},
                    {x: 0, y: 5, color: "blue"},
                    {x: 5, y: 0, color: "pink"}
                ],
                initialStaticPieces: [{x: 0, y: 0, color: "teal"}],
                spawnSequence: [
                    {x: 2, y: 2, color: "red"},
                    {x: 3, y: 3, color: "red"},
                    {x: 1, y: 4, color: "blue"},
                    {x: 0, y: 4, color: "blue"},
                    {x: 4, y: 1, color: "pink"},
                    {x: 4, y: 0, color: "pink"},
                    {x: 4, y: 4, color: "yellow"},
                    {x: 5, y: 4, color: "yellow"}
                ],
                goalPattern: [
                    {x: 5, y: 5, requiredColor: "yellow"},
                    {x: 0, y: 0, requiredColor: "teal"},
                    {x: 0, y: 5, requiredColor: "blue"},
                    {x: 5, y: 0, requiredColor: "pink"}
                ],
                palette: {avatarDefault: "gray", spawnDock: "black", triggerCell: "white"}
            }
        };

        // ============================
        // GAME STATE
        // ============================
        let currentLevel = 1;
        let avatar = {x: 0, y: 0, color: "gray"};
        let board = [];
        let spawnIndex = 0;
        let spawnHistory = [];
        let gameLog = [];
        let levelCompleted = false;

        // ============================
        // INITIALIZATION
        // ============================
        function initGame() {
            const level = LEVELS[currentLevel];
            avatar = {
                x: level.avatarStart.x,
                y: level.avatarStart.y,
                color: level.palette.avatarDefault
            };

            // Initialize empty board
            board = [];
            for (let y = 0; y < level.boardSize; y++) {
                board[y] = [];
                for (let x = 0; x < level.boardSize; x++) {
                    board[y][x] = {color: null, isTemplate: false, isGoal: false};
                }
            }

            // Place hint template cells
            level.hintTemplateCells.forEach(cell => {
                board[cell.y][cell.x] = {color: cell.color, isTemplate: true, isGoal: false};
            });

            // Place initial static pieces
            level.initialStaticPieces.forEach(piece => {
                board[piece.y][piece.x] = {color: piece.color, isTemplate: false, isGoal: false};
            });

            // Mark goal pattern cells
            level.goalPattern.forEach(goal => {
                board[goal.y][goal.x].isGoal = true;
            });

            spawnIndex = 0;
            spawnHistory = [];
            levelCompleted = false;

            logEvent({
                type: "level_start",
                level: currentLevel,
                timestamp: Date.now()
            });

            renderBoard();
        }

        // ============================
        // RENDERING
        // ============================
        function renderBoard() {
            const level = LEVELS[currentLevel];
            const gridElement = document.getElementById('grid');
            gridElement.style.gridTemplateColumns = `repeat(${level.boardSize}, 40px)`;
            gridElement.innerHTML = '';

            for (let y = 0; y < level.boardSize; y++) {
                for (let x = 0; x < level.boardSize; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';

                    // Determine cell color
                    let cellColor = '#222';
                    const boardCell = board[y][x];

                    if (boardCell.color) {
                        cellColor = boardCell.color;
                    }

                    // Check if this is spawn dock
                    const isDock = level.spawnDockCells.some(dock => dock.x === x && dock.y === y);
                    if (isDock && !boardCell.color) {
                        cellColor = level.palette.spawnDock;
                    }

                    // Check if this is trigger cell
                    if (level.spawnTriggerCell.x === x && level.spawnTriggerCell.y === y && !boardCell.color) {
                        cellColor = level.palette.triggerCell;
                    }

                    cell.style.backgroundColor = cellColor;

                    // Draw avatar
                    if (avatar.x === x && avatar.y === y) {
                        cell.classList.add('avatar');
                        cell.style.backgroundColor = avatar.color;
                    }

                    gridElement.appendChild(cell);
                }
            }
        }

        // ============================
        // MOVEMENT & GAME LOGIC
        // ============================
        function moveAvatar(dx, dy) {
            if (levelCompleted) return;

            const level = LEVELS[currentLevel];
            const newX = avatar.x + dx;
            const newY = avatar.y + dy;

            // Check bounds
            if (newX < 0 || newX >= level.boardSize || newY < 0 || newY >= level.boardSize) {
                return;
            }

            const oldX = avatar.x;
            const oldY = avatar.y;

            // Move avatar
            avatar.x = newX;
            avatar.y = newY;

            logEvent({
                type: "move",
                from: {x: oldX, y: oldY},
                to: {x: newX, y: newY},
                avatarColor: avatar.color,
                timestamp: Date.now()
            });

            // Check if avatar picks up color from spawned piece
            const targetCell = board[newY][newX];
            if (targetCell.color && !targetCell.isTemplate) {
                avatar.color = targetCell.color;
                board[newY][newX] = {color: null, isTemplate: false, isGoal: targetCell.isGoal};

                logEvent({
                    type: "pickup",
                    position: {x: newX, y: newY},
                    color: avatar.color,
                    timestamp: Date.now()
                });
            }

            // Try to deposit color in old position
            const oldCell = board[oldY][oldX];
            if (avatar.color !== level.palette.avatarDefault && !oldCell.color && !oldCell.isTemplate) {
                // Check if old position has orthogonal neighbor with same color
                if (hasOrthogonalNeighborWithColor(oldX, oldY, avatar.color)) {
                    board[oldY][oldX].color = avatar.color;

                    logEvent({
                        type: "deposit",
                        position: {x: oldX, y: oldY},
                        color: avatar.color,
                        timestamp: Date.now()
                    });
                } else {
                    logEvent({
                        type: "deposit_failed",
                        position: {x: oldX, y: oldY},
                        color: avatar.color,
                        reason: "no_adjacent_same_color",
                        timestamp: Date.now()
                    });
                }
            }

            // Reset avatar color after move
            avatar.color = level.palette.avatarDefault;

            // Check spawn trigger
            if (newX === level.spawnTriggerCell.x && newY === level.spawnTriggerCell.y) {
                checkAndSpawn();
            }

            renderBoard();
            checkWinCondition();
        }

        function hasOrthogonalNeighborWithColor(x, y, color) {
            const level = LEVELS[currentLevel];
            const directions = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];

            for (const dir of directions) {
                const nx = x + dir.dx;
                const ny = y + dir.dy;

                if (nx >= 0 && nx < level.boardSize && ny >= 0 && ny < level.boardSize) {
                    if (board[ny][nx].color === color) {
                        return true;
                    }
                }
            }

            return false;
        }

        function checkAndSpawn() {
            const level = LEVELS[currentLevel];
            const trigger = level.spawnTriggerCell;

            // Count adjacent dock cells
            let adjacentDockCount = 0;
            const directions = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];

            for (const dir of directions) {
                const nx = trigger.x + dir.dx;
                const ny = trigger.y + dir.dy;

                if (level.spawnDockCells.some(dock => dock.x === nx && dock.y === ny)) {
                    adjacentDockCount++;
                }
            }

            logEvent({
                type: "spawn_trigger_check",
                position: {x: trigger.x, y: trigger.y},
                adjacentDockCount: adjacentDockCount,
                required: level.spawnAdjacencyRequirement,
                timestamp: Date.now()
            });

            if (adjacentDockCount >= level.spawnAdjacencyRequirement) {
                attemptSpawn();
            }
        }

        function attemptSpawn() {
            const level = LEVELS[currentLevel];

            if (spawnIndex >= level.spawnSequence.length) {
                logEvent({
                    type: "spawn_exhausted",
                    timestamp: Date.now()
                });
                return;
            }

            // Try to spawn pieces in sequence
            let spawned = false;
            let attempts = 0;

            while (!spawned && spawnIndex < level.spawnSequence.length && attempts < level.spawnSequence.length) {
                const spawn = level.spawnSequence[spawnIndex];
                const targetCell = board[spawn.y][spawn.x];

                if (!targetCell.color && !targetCell.isTemplate) {
                    // Spawn successful
                    board[spawn.y][spawn.x].color = spawn.color;
                    spawnHistory.push({
                        index: spawnIndex,
                        position: {x: spawn.x, y: spawn.y},
                        color: spawn.color,
                        timestamp: Date.now()
                    });

                    logEvent({
                        type: "spawn_placed",
                        spawnIndex: spawnIndex,
                        position: {x: spawn.x, y: spawn.y},
                        color: spawn.color,
                        timestamp: Date.now()
                    });

                    spawnIndex++;
                    spawned = true;
                } else {
                    // Cell occupied, skip to next
                    logEvent({
                        type: "spawn_skipped",
                        spawnIndex: spawnIndex,
                        position: {x: spawn.x, y: spawn.y},
                        reason: "cell_occupied",
                        timestamp: Date.now()
                    });

                    spawnIndex++;
                    attempts++;
                }
            }
        }

        // ============================
        // WIN CONDITION
        // ============================
        function checkWinCondition() {
            const level = LEVELS[currentLevel];
            let allMatch = true;

            for (const goal of level.goalPattern) {
                const cell = board[goal.y][goal.x];
                if (cell.color !== goal.requiredColor) {
                    allMatch = false;
                    break;
                }
            }

            if (allMatch && !levelCompleted) {
                levelCompleted = true;

                logEvent({
                    type: "level_complete",
                    level: currentLevel,
                    timestamp: Date.now()
                });

                triggerWin();
            }
        }

        function triggerWin() {
            // Ripple effect
            const grid = document.getElementById('grid');
            grid.classList.add('ripple-effect');

            setTimeout(() => {
                grid.classList.remove('ripple-effect');

                // Show overlay
                const overlay = document.getElementById('overlay');
                const message = document.getElementById('overlay-message');
                const nextBtn = document.getElementById('next-level-btn');

                if (currentLevel === 5) {
                    message.textContent = "All Levels Complete!";
                    nextBtn.style.display = "none";
                    document.getElementById('restart-btn').style.display = "block";
                } else {
                    message.textContent = "Level Complete!";
                    nextBtn.style.display = "block";
                }

                overlay.classList.add('show');
            }, 600);
        }

        // ============================
        // LOGGING
        // ============================
        function logEvent(event) {
            gameLog.push(event);
        }

        function downloadData() {
            const data = {
                currentLevel: currentLevel,
                gameLog: gameLog,
                spawnHistory: spawnHistory,
                exportTime: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `game-data-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            logEvent({
                type: "data_downloaded",
                timestamp: Date.now()
            });
        }

        // ============================
        // EVENT LISTENERS
        // ============================
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    moveAvatar(0, -1);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    moveAvatar(0, 1);
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    moveAvatar(-1, 0);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    moveAvatar(1, 0);
                    break;
            }
        });

        document.getElementById('download-btn').addEventListener('click', downloadData);

        document.getElementById('restart-btn').addEventListener('click', () => {
            currentLevel = 1;
            document.getElementById('restart-btn').style.display = "none";
            document.getElementById('overlay').classList.remove('show');
            initGame();
        });

        document.getElementById('next-level-btn').addEventListener('click', () => {
            if (currentLevel < 5) {
                currentLevel++;
                document.getElementById('overlay').classList.remove('show');
                initGame();
            }
        });

        // ============================
        // START GAME
        // ============================
        initGame();
    </script>
</body>
</html>